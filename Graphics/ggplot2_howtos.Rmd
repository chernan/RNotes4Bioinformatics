Ggplot2: how to...
================================================================================

> How to draw a multi-density plot from a data frame or a list
> 
> How to draw a scatterplot and assign color as a function of another variable

--------------------------------------------------------------------------------

How to draw a multi-density plot from a data frame or a list
--------------------------------------------------------------------------------

Before, we create a sample data set for our test. In this case we use a list, but a data frame could also be used in the case where all elements have the same length (just replace list() by data.frame()). 
```{r}
testDF <- list(
    mean0 = rnorm(1000),
    mean1 = rnorm(1200, mean=1)
)
```

First step is to transform this wide format into long format. The resulting data frame will have two columns titled "values" (with the data) and "ind" (with labels corresponding to column names).
```{r}
longDF <- stack(testDF)
```

And then we plot the densities. Library ggplot2 is loaded, and we use the qplot() function, specifying that "values" column contains the x coordinates (all data being in longDF), that we want the density to be displayed, and that values should be split according to the categories in "ind".
```{r}
library("ggplot2")
qplot(x=values, data=longDF, geom="density", colour=ind)
```

One-block code:
```{r, eval=FALSE}
testDF <- list(
    mean0 = rnorm(1000),
    mean1 = rnorm(1200, mean=1)
)
longDF <- stack(testDF)
library("ggplot2")
qplot(x=values, data=longDF, geom="density", colour=ind)
```


--------------------------------------------------------------------------------


How to draw a scatterplot and assign color as a function of another variable
--------------------------------------------------------------------------------


Dataset: we use the 'iris' data set. We want to plot petal length versus width, like this graph :
```{r}
data(iris)
qplot(x=Petal.Length, y=Petal.Width, data=iris)
```
and color the points depending on the petal area (approximated as length*width).
```{r}
petalArea <- iris$Petal.Length * iris$Petal.Width
```

### Continuous values, or a large set of discrete values 

For continuous values, use the cut() function to define intervals and create a factor.
```{r}
cutPetalArea <- cut(petalArea,
                    breaks=c(min(petalArea), mean(petalArea), max(petalArea)),
                    include.lowest=T)
```

Then use this factor for the 'colour' parameter.
```{r}
p <- ggplot(data=iris, 
            aes(x=Petal.Length, 
                y=Petal.Width, 
                colour=cutPetalArea)) + geom_point()
p
```

Or simply:

```{r}
qplot(x=Petal.Length, y=Petal.Width, data=iris, colour=cutPetalArea)
```

### Discrete values, small finite set

```{r}
## We artificially round all values to create a finite set of integers...
roundedPetalArea <- round(petalArea, digits=0)
```

For a small finite set of discrete values, we can directly create a factor from the different values. 

```{r}
p <- ggplot(data=iris, 
            aes(x=Petal.Length, 
                y=Petal.Width, 
                colour=factor(roundedPetalArea))) + geom_point()
p
```

Or simply:

```{r}
qplot(x=Petal.Length, y=Petal.Width, data=iris, colour=factor(roundedPetalArea))
```

