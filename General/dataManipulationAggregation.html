<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="description" content="A collection of notes describing a few aspects of R for bioinformatics.">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link rel="stylesheet" href="../stylesheets/stylesheet.css" media="screen"/>
  <link rel="stylesheet" href="../stylesheets/pygment_trac.css"/>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="../javascripts/script.js"></script>
  <title>Data manipulation : aggregation, merge and format changes</title>
</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">R Notes for Bioinformatics</h1>
    </header>
    <div id="container">
      <p class="tagline">A collection of notes describing a few aspects of R for bioinformatics.</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/chernan/RNotes4Bioinformatics/tarball/gh-pages" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/chernan/RNotes4Bioinformatics/zipball/gh-pages" class="download-button zip"><span>Download</span></a>
          <a href="https://github.com/chernan/RNotes4Bioinformatics" class="code">View R Notes for Bioinformatics on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
        
<h1>Data manipulation : aggregation, merge and format changes</h1>

<p>This page describes how to apply functions on each line/column of a data frame, or on lines grouped in subsets using another variable.
It will also show how to create a contingency table, and how to change from long to wide format, and reversely.</p>

<ol>
<li>Apply a function on a list/data.frame (apply, lapply, sapply)</li>
<li>Aggregation (tapply, aggregate, by)</li>
<li>Merge</li>
<li>Split</li>
<li>Contingency table</li>
<li>Wide and long formats</li>
</ol>

<hr/>

<h2>Apply a function on a list/data.frame</h2>

<p>The &ldquo;apply&rdquo; family of functions is useful when applying the same code on each element/line of a vector, list, data.frame etc. Each of the function can be applied on a list (or data frame) but returns results in a different format.</p>

<h3>apply()</h3>

<p>The most generic function.<br/>
Use it to apply another function on each column/row of a data frame.<br/>
The function to be applied can be already defined, or defined on-the-fly.<br/>
Supplementary parameters can be transmitted to already defined functions.  </p>

<ul>
<li>Use MAR=1 to loop on rows</li>
<li>Use MAR=2 to loop on columns</li>
</ul>

<pre><code class="r">mydf &lt;- data.frame(m0sd1 = rnorm(200, mean = 0, sd = 1), m0sd10 = rnorm(200, 
    mean = 0, sd = 10), m0sd.1 = rnorm(200, mean = 0, sd = 0.1), m1.5sd1 = rnorm(200, 
    mean = 1.5, sd = 1), m0sd5 = rnorm(200, mean = 0, sd = 5))
## Already defined function
apply(mydf, MARGIN = 2, mean)
</code></pre>

<pre><code>##     m0sd1    m0sd10    m0sd.1   m1.5sd1     m0sd5 
## -0.059248  0.641841  0.006092  1.662241  0.457147
</code></pre>

<pre><code class="r">## Equivalent to mean(column, trim=0.1)
apply(mydf, MARGIN = 2, mean, trim = 0.1)
</code></pre>

<pre><code>##     m0sd1    m0sd10    m0sd.1   m1.5sd1     m0sd5 
## -0.047388  0.699333  0.008574  1.673356  0.480492
</code></pre>

<pre><code class="r">## Function defined on-the-fly
apply(mydf, MARGIN = 2, FUN = function(column) {
    return(c(mean(column), median(column)))
})
</code></pre>

<pre><code>##         m0sd1  m0sd10   m0sd.1 m1.5sd1  m0sd5
## [1,] -0.05925 0.64184 0.006092   1.662 0.4571
## [2,] -0.02901 0.09039 0.008551   1.653 0.6613
</code></pre>

<p>NB: When the function to be applied is simple, other specialized function are often more efficient, like rowSums(matrix) or rowMeans(matrix).</p>

<h3>lapply()</h3>

<p>Use it to apply a function on the elements of a list. It can be interesting to use <code>as.data.frame</code> on the result to get it in a more handy format. A better approach is to directly use <code>sapply()</code>.</p>

<pre><code class="r">mylist &lt;- list(m0sd1 = rnorm(200, mean = 0, sd = 1), m0sd10 = rnorm(2000, mean = 0, 
    sd = 10), m0sd.1 = rnorm(20, mean = 0, sd = 0.1), m1.5sd1 = rnorm(200, mean = 1.5, 
    sd = 1), m0sd5 = rnorm(200, mean = 0, sd = 5))
result &lt;- lapply(mylist, FUN = function(x) {
    return(c(mean = mean(x), median = median(x)))
})
result
</code></pre>

<pre><code>## $m0sd1
##     mean   median 
## -0.07216 -0.15783 
## 
## $m0sd10
##    mean  median 
## -0.2937 -0.2853 
## 
## $m0sd.1
##    mean  median 
## 0.01812 0.00932 
## 
## $m1.5sd1
##   mean median 
##  1.537  1.475 
## 
## $m0sd5
##    mean  median 
## -0.1611 -0.3490
</code></pre>

<pre><code class="r">as.data.frame(result)
</code></pre>

<pre><code>##           m0sd1  m0sd10  m0sd.1 m1.5sd1   m0sd5
## mean   -0.07216 -0.2937 0.01812   1.537 -0.1611
## median -0.15783 -0.2853 0.00932   1.475 -0.3490
</code></pre>

<h3>sapply()</h3>

<p>Use it to apply on the elements of a list and simplify the result to a vector or a matrix, if possible.</p>

<pre><code class="r">mylist &lt;- list(m0sd1 = rnorm(200, mean = 0, sd = 1), m0sd10 = rnorm(2000, mean = 0, 
    sd = 10), m0sd.1 = rnorm(20, mean = 0, sd = 0.1), m1.5sd1 = rnorm(200, mean = 1.5, 
    sd = 1), m0sd5 = rnorm(200, mean = 0, sd = 5))
sapply(mylist, FUN = function(col) {
    return(c(mean(col), median(col)))
})
</code></pre>

<pre><code>##         m0sd1   m0sd10     m0sd.1 m1.5sd1   m0sd5
## [1,] -0.05533 -0.04112 -0.0062452   1.325 -0.3524
## [2,] -0.11246  0.14949  0.0005626   1.289 -0.3461
</code></pre>

<hr/>

<h2>Aggregation</h2>

<h3>tapply()</h3>

<blockquote>
<p>Usage : tapply(data, factorForGroups, FUN)</p>
</blockquote>

<p>Use it to apply a function FUN on a <em>vector</em>, after aggregating the values using a factor. </p>

<pre><code class="r">mydf &lt;- data.frame(age = c(19, 36, 63, 31, 43, 86), height = c(157, 167, 182, 
    172, 168, 173), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;))
tapply(mydf$age, INDEX = mydf$sex, FUN = mean)
</code></pre>

<pre><code>##     F     M 
## 28.67 64.00
</code></pre>

<p>On a <em>data frame</em>, one can use split to generate a list and combine it with lapply() or mapply().</p>

<pre><code class="r">mydf &lt;- data.frame(age = c(19, 36, 63, 31, 43, 86), height = c(157, 167, 182, 
    172, 168, 173), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;))
split(mydf, mydf$sex)
</code></pre>

<pre><code>## $F
##   age height sex
## 1  19    157   F
## 2  36    167   F
## 4  31    172   F
## 
## $M
##   age height sex
## 3  63    182   M
## 5  43    168   M
## 6  86    173   M
</code></pre>

<pre><code class="r">lapply(split(mydf[, c(&quot;age&quot;, &quot;height&quot;)], mydf$sex), FUN = colMeans)
</code></pre>

<pre><code>## $F
##    age height 
##  28.67 165.33 
## 
## $M
##    age height 
##   64.0  174.3
</code></pre>

<h3>aggregate</h3>

<p>aggregate(x, by, FUN) </p>

<p>Works similarly to tapply() but:</p>

<ul>
<li>on a whole data.frame (multiple columns)</li>
<li>the &#39;by&#39; argument must be a list</li>
<li><strong>only produces scalar summaries</strong></li>
</ul>

<pre><code class="r">mydf &lt;- data.frame(age = c(19, 36, 63, 31, 43, 86), height = c(157, 167, 182, 
    172, 168, 173), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;))
aggregate(mydf[, 1:2], mydf[&quot;sex&quot;], mean)
</code></pre>

<pre><code>##   sex   age height
## 1   F 28.67  165.3
## 2   M 64.00  174.3
</code></pre>

<pre><code class="r">aggregate(mydf[, 1:2], mydf[&quot;sex&quot;], paste0)
</code></pre>

<pre><code>##   sex age.1 age.2 age.3 height.1 height.2 height.3
## 1   F    19    36    31      157      167      172
## 2   M    63    43    86      182      168      173
</code></pre>

<pre><code class="r">data(iris)
head(iris, 3)
</code></pre>

<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
</code></pre>

<pre><code class="r">## Note that iris[&#39;Species&#39;] is a list (as iris[5]), instead of
## iris$Species which is a vector (as iris[,5])
aggregate(iris[, 1:4], iris[&quot;Species&quot;], FUN = mean)
</code></pre>

<pre><code>##      Species Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa        5.006       3.428        1.462       0.246
## 2 versicolor        5.936       2.770        4.260       1.326
## 3  virginica        6.588       2.974        5.552       2.026
</code></pre>

<h3>by</h3>

<p>This function is similar to tapply, but more general as it applies to data frames.<br/>
It first splits the input into multiple data frames and applies the function FUN on each sub-data frame.  </p>

<pre><code class="r">mydf &lt;- data.frame(age = c(19, 36, 63, 31, 43, 86), height = c(157, 167, 182, 
    172, 168, 173), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;))
by(mydf[, 1:2], INDICES = mydf$sex, FUN = colMeans)
</code></pre>

<pre><code>## mydf$sex: F
##    age height 
##  28.67 165.33 
## -------------------------------------------------------- 
## mydf$sex: M
##    age height 
##   64.0  174.3
</code></pre>

<pre><code class="r">mydf &lt;- data.frame(age = c(19, 36, 63, 31, 43, 86), height = c(157, 167, 182, 
    172, 168, 173), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;))
by(mydf[, 1:2], INDICES = mydf$sex, FUN = function(df) {
    apply(df, 2, summary)
})
</code></pre>

<pre><code>## mydf$sex: F
##          age height
## Min.    19.0    157
## 1st Qu. 25.0    162
## Median  31.0    167
## Mean    28.7    165
## 3rd Qu. 33.5    170
## Max.    36.0    172
## -------------------------------------------------------- 
## mydf$sex: M
##          age height
## Min.    43.0    168
## 1st Qu. 53.0    170
## Median  63.0    173
## Mean    64.0    174
## 3rd Qu. 74.5    178
## Max.    86.0    182
</code></pre>

<hr/>

<h2>Merge</h2>

<h3>merge</h3>

<p>Merge two data frames, by column or by row. By default the function finds all common column names and use them all.<br/>
Interesting parameters include :</p>

<ul>
<li>&#39;by&#39; (by.x, by.y) to specify common columns to use for the merge</li>
<li>&#39;all&#39; (all.x, all.y) to specify if all lines should be kept (even the ones without correspondance in the other data frame). </li>
</ul>

<pre><code class="r">x &lt;- data.frame(index = c(2, 3, 1), fruit = c(&quot;orange&quot;, &quot;lemon&quot;, &quot;grapefruit&quot;))
y &lt;- data.frame(index = c(3, 1, 2, 1), quantity = c(13, 6, 3, 5))
merge(x, y)
</code></pre>

<pre><code>##   index      fruit quantity
## 1     1 grapefruit        6
## 2     1 grapefruit        5
## 3     2     orange        3
## 4     3      lemon       13
</code></pre>

<p>A good practice is to specify each time by which column you want to merge for x and y.</p>

<h3>Union (Set operations)</h3>

<p>Intersetcion between values of two sets (vectors). Any duplicated value is discarded.</p>

<pre><code class="r">set.seed(0)
x &lt;- trunc(runif(10, min = 0, max = 100), 0)
y &lt;- trunc(runif(10, min = 0, max = 100), 0)
x
</code></pre>

<pre><code>##  [1] 89 26 37 57 90 20 89 94 66 62
</code></pre>

<pre><code class="r">y
</code></pre>

<pre><code>##  [1]  6 20 17 68 38 76 49 71 99 38
</code></pre>

<pre><code class="r">union(x, y)
</code></pre>

<pre><code>##  [1] 89 26 37 57 90 20 94 66 62  6 17 68 38 76 49 71 99
</code></pre>

<p>Other set operations are also possible. </p>

<ul>
<li>Intersection with intersect(x, y)</li>
<li>Difference (which ones of x are not in y) with setdiff(x,y). is.element() returns boolean values, as well as %in%.</li>
</ul>

<p>match(x, reflist) 
is a more general way to find which values of a new list x are in a reference list (and at which position).</p>

<hr/>

<h2>Split</h2>

<p>split() splits a vector (or rows of a data frame) into separate elements of a list, ready for further processing.<br/>
See tapply().</p>

<hr/>

<h2>Contingency table</h2>

<p>A contingency table counts the combinations of two factors. To create a contingency table, use the <code>table()</code> function.</p>

<pre><code class="r">x &lt;- data.frame(fruit = c(&quot;orange&quot;, &quot;lemon&quot;, &quot;lemon&quot;, &quot;grapefruit&quot;, &quot;grapefruit&quot;, 
    &quot;orange&quot;, &quot;lemon&quot;), country = c(&quot;Spain&quot;, &quot;Spain&quot;, &quot;California&quot;, &quot;California&quot;, 
    &quot;Spain&quot;, &quot;Spain&quot;, &quot;California&quot;))
table(x)
</code></pre>

<pre><code>##             country
## fruit        California Spain
##   grapefruit          1     1
##   lemon               2     1
##   orange              0     2
</code></pre>

<hr/>

<h2>Wide and long formats</h2>

<p>stack() transforms a matrix with headers (wide format), into one 2-columns data-frame with measurements/labels (long format).</p>

<pre><code class="r">mydf &lt;- data.frame(x = trunc(runif(10, min = 0, max = 100), 0), y = round(runif(10, 
    min = 0, max = 1), 1))
stack(mydf)
</code></pre>

<pre><code>##    values ind
## 1    77.0   x
## 2    93.0   x
## 3    21.0   x
## 4    65.0   x
## 5    12.0   x
## 6    26.0   x
## 7    38.0   x
## 8     1.0   x
## 9    38.0   x
## 10   86.0   x
## 11    0.3   y
## 12    0.5   y
## 13    0.6   y
## 14    0.5   y
## 15    0.2   y
## 16    0.8   y
## 17    0.7   y
## 18    0.8   y
## 19    0.1   y
## 20    0.7   y
</code></pre>

<p>Correlation need wide format, modeling need long format.</p>

<p>reshape() has more possibilities, and is consequently more complex.</p>

<hr/>

<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a><br />This work by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Celine Hernandez</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p>

        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/chernan" class="avatar"><img src="https://0.gravatar.com/avatar/87ffdd8b5458b07e667a4e23a636b8dd?d=https%3A%2F%2Fidenticons.github.com%2F52da2d5c8b30ddc47bfbd75cd46d8a65.png&amp;s=30" width="48" height="48"/></a> <a href="https://github.com/chernan">chernan</a> maintains <a href="https://github.com/chernan/RNotes4Bioinformatics">R Notes for Bioinformatics</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br/>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/chernan/RNotes4Bioinformatics/tarball/master" class="tar">tar</a><a href="https://github.com/chernan/RNotes4Bioinformatics/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>

  
</body>


</html>
